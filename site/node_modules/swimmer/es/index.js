import _regeneratorRuntime from "babel-runtime/regenerator";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var defaultConfig = {
  concurrency: 5,
  started: true,
  tasks: []
};

export function createPool() {
  var _this = this;

  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;

  var _defaultConfig$config = _extends({}, defaultConfig, config),
      concurrency = _defaultConfig$config.concurrency,
      started = _defaultConfig$config.started,
      tasks = _defaultConfig$config.tasks;

  var onSettles = [];
  var onErrors = [];
  var onSuccesses = [];
  var running = started;
  var active = [];
  var pending = tasks;
  var currentConcurrency = concurrency;

  var tick = function tick() {
    if (!running) {
      return;
    }
    if (!pending.length && !active.length) {
      onSettles.forEach(function (d) {
        return d();
      });
      return;
    }

    var _loop = function _loop() {
      var nextFn = pending.shift();
      active.push(nextFn)
      /* eslint-disable no-loop-func */
      ;_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var success, res, error;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                success = false;
                res = void 0;
                error = void 0;
                _context.prev = 3;
                _context.next = 6;
                return nextFn();

              case 6:
                res = _context.sent;

                success = true;
                _context.next = 13;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](3);

                error = _context.t0;

              case 13:
                active = active.filter(function (d) {
                  return d !== nextFn;
                });
                if (success) {
                  nextFn.resolve(res);
                  onSuccesses.forEach(function (d) {
                    return d(res, nextFn);
                  });
                } else {
                  nextFn.reject(error);
                  onErrors.forEach(function (d) {
                    return d(error, nextFn);
                  });
                }
                tick();

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, _this, [[3, 10]]);
      }))();
      /* eslint-enable no-loop-func */
    };

    while (active.length < currentConcurrency && pending.length) {
      _loop();
    }
  };

  var api = {
    add: function add(fn, priority) {
      return new Promise(function (resolve, reject) {
        if (priority) {
          pending.unShift(fn);
        } else {
          pending.push(fn);
        }
        fn.resolve = resolve;
        fn.reject = reject;
        tick();
      });
    },
    throttle: function throttle(n) {
      currentConcurrency = n;
    },
    onSettled: function onSettled(cb) {
      onSettles.push(cb);
      return function () {
        onSettles = onSettles.filter(function (d) {
          return d !== cb;
        });
      };
    },
    onError: function onError(cb) {
      onErrors.push(cb);
      return function () {
        onErrors = onErrors.filter(function (d) {
          return d !== cb;
        });
      };
    },
    onSuccess: function onSuccess(cb) {
      onSuccesses.push(cb);
      return function () {
        onSuccesses = onSuccesses.filter(function (d) {
          return d !== cb;
        });
      };
    },
    stop: function stop() {
      running = false;
    },
    start: function start() {
      running = true;
      tick();
    },
    clear: function clear() {
      pending = [];
    },
    getActive: function getActive() {
      return active;
    },
    getPending: function getPending() {
      return pending;
    },
    getAll: function getAll() {
      return [].concat(active, pending);
    },
    isRunning: function isRunning() {
      return running;
    },
    isSettled: function isSettled() {
      return !running && !active.length && !pending.length;
    }
  };

  return api;
}

export function poolAll(tasks, concurrency) {
  var _this2 = this;

  return new Promise(function (resolve, reject) {
    var pool = createPool({
      concurrency: concurrency
    });
    var results = [];
    pool.onSettled(function () {
      resolve(results);
    });
    pool.onError(function (err) {
      reject(err);
    });
    tasks.forEach(function (task, i) {
      pool.add(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var res;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return task();

              case 2:
                res = _context2.sent;

                results[i] = res;
                return _context2.abrupt("return", res);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, _this2);
      })));
    });
    pool.start();
  });
}