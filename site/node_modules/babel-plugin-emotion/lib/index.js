'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.hashArray = hashArray;
exports.hoistPureArgs = hoistPureArgs;
exports.replaceCssWithCallExpression = replaceCssWithCallExpression;
exports.buildStyledCallExpression = buildStyledCallExpression;
exports.buildStyledObjectCallExpression = buildStyledObjectCallExpression;

exports.default = function (babel) {
  var t = babel.types;


  return {
    name: 'emotion', // not required
    inherits: require('babel-plugin-syntax-jsx'),
    visitor: {
      Program: {
        enter: function enter(path, state) {
          var hasFilepath = path.hub.file.opts.filename && path.hub.file.opts.filename !== 'unknown';
          state.emotionImportPath = 'emotion';
          if (state.opts.primaryInstance !== undefined) {
            state.emotionImportPath = getInstancePathToImport(state.opts.primaryInstance, path.hub.file.opts.filename);
          }

          state.importedNames = _extends({}, defaultImportedNames, state.opts.importedNames);

          var imports = [];

          var isModule = false;

          for (var _iterator = path.node.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var _node = _ref;

            if (t.isModuleDeclaration(_node)) {
              isModule = true;
              break;
            }
          }

          if (isModule) {
            path.traverse({
              ImportDeclaration: {
                exit: function exit(path) {
                  var node = path.node;


                  var imported = [];
                  var specifiers = [];

                  imports.push({
                    source: node.source.value,
                    imported: imported,
                    specifiers: specifiers
                  });

                  for (var _iterator2 = path.get('specifiers'), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                    var _ref2;

                    if (_isArray2) {
                      if (_i2 >= _iterator2.length) break;
                      _ref2 = _iterator2[_i2++];
                    } else {
                      _i2 = _iterator2.next();
                      if (_i2.done) break;
                      _ref2 = _i2.value;
                    }

                    var specifier = _ref2;

                    var local = specifier.node.local.name;

                    if (specifier.isImportDefaultSpecifier()) {
                      imported.push('default');
                      specifiers.push({
                        kind: 'named',
                        imported: 'default',
                        local: local
                      });
                    }

                    if (specifier.isImportSpecifier()) {
                      var importedName = specifier.node.imported.name;
                      imported.push(importedName);
                      specifiers.push({
                        kind: 'named',
                        imported: importedName,
                        local: local
                      });
                    }
                  }
                }
              }
            });
          }
          var emotionPaths = defaultEmotionPaths.concat((state.opts.instances || []).map(function (instancePath) {
            return getInstancePathToCompare(instancePath, process.cwd());
          }));
          var dirname = hasFilepath ? _path2.default.dirname(path.hub.file.opts.filename) : '';
          imports.forEach(function (_ref3) {
            var source = _ref3.source,
                imported = _ref3.imported,
                specifiers = _ref3.specifiers;

            if (emotionPaths.indexOf(getInstancePathToCompare(source, dirname)) !== -1) {
              var _importedNames = specifiers.filter(function (v) {
                return importedNameKeys.indexOf(v.imported) !== -1;
              }).reduce(function (acc, _ref4) {
                var _extends2;

                var imported = _ref4.imported,
                    local = _ref4.local;
                return _extends({}, acc, (_extends2 = {}, _extends2[imported === 'default' ? 'styled' : imported] = local, _extends2));
              }, defaultImportedNames);
              state.importedNames = _extends({}, _importedNames, state.opts.importedNames);
            }
          });
          state.cssPropIdentifiers = [];
          state.extractStatic =
          // path.hub.file.opts.filename !== 'unknown' ||
          state.opts.extractStatic;

          state.staticRules = [];

          state.insertStaticRules = function (staticRules) {
            var _state$staticRules;

            (_state$staticRules = state.staticRules).push.apply(_state$staticRules, staticRules);
          };
        },
        exit: function exit(path, state) {
          if (state.staticRules.length !== 0) {
            var toWrite = state.staticRules.join('\n').trim();
            var filenameArr = path.hub.file.opts.filename.split('.');
            filenameArr.pop();
            filenameArr.push('emotion', 'css');
            var cssFilename = filenameArr.join('.');
            var exists = _fs2.default.existsSync(cssFilename);
            (0, _helperModuleImports.addSideEffect)(path, './' + _path2.default.basename(cssFilename));
            if (exists ? _fs2.default.readFileSync(cssFilename, 'utf8') !== toWrite : true) {
              if (!exists) {
                (0, _touch.touchSync)(cssFilename);
              }
              _fs2.default.writeFileSync(cssFilename, toWrite);
            }
          }
        }
      },
      JSXOpeningElement: function JSXOpeningElement(path, state) {
        (0, _cssProp2.default)(path, state, t);
        if (state.opts.hoist) {
          path.traverse({
            CallExpression: function CallExpression(callExprPath) {
              if (callExprPath.node.callee.name === state.importedNames.css || state.cssPropIdentifiers.indexOf(callExprPath.node.callee) !== -1) {
                hoistPureArgs(callExprPath);
              }
            }
          });
        }
      },

      CallExpression: {
        enter: function enter(path, state) {
          // $FlowFixMe
          if (path[visited]) {
            return;
          }
          try {
            if (t.isIdentifier(path.node.callee)) {
              switch (path.node.callee.name) {
                case state.importedNames.css:
                case state.importedNames.keyframes:
                  {
                    path.addComment('leading', '#__PURE__');
                    var label = (0, _babelUtils.getLabel)((0, _babelUtils.getIdentifierName)(path, t), state.opts.autoLabel, state.opts.labelFormat, state.file.opts.filename);
                    if (label) {
                      path.node.arguments.push(t.stringLiteral('label:' + label + ';'));
                    }
                  }
                // eslint-disable-next-line no-fallthrough
                case state.importedNames.injectGlobal:
                  if (state.opts.sourceMap === true && path.node.loc !== undefined) {
                    path.node.arguments.push(t.stringLiteral((0, _sourceMap.addSourceMaps)(path.node.loc.start, state)));
                  }
              }
            }

            if (t.isCallExpression(path.node.callee) && path.node.callee.callee.name === state.importedNames.styled || t.isMemberExpression(path.node.callee) && t.isIdentifier(path.node.callee.object) && path.node.callee.object.name === state.importedNames.styled) {
              var identifier = t.isCallExpression(path.node.callee) ? path.node.callee.callee : path.node.callee.object;
              path.replaceWith(buildStyledObjectCallExpression(path, state, identifier, t));

              if (state.opts.hoist) {
                hoistPureArgs(path);
              }
            }
          } catch (e) {
            throw path.buildCodeFrameError(e);
          }
          // $FlowFixMe
          path[visited] = true;
        },
        exit: function exit(path, state) {
          try {
            if (path.node.callee && path.node.callee.property && path.node.callee.property.name === 'withComponent') {
              if (path.node.arguments.length === 1) {
                path.node.arguments.push(t.objectExpression([buildTargetObjectProperty(path, state, t)]));
              }
            }
          } catch (e) {
            throw path.buildCodeFrameError(e);
          }
        }
      },
      TaggedTemplateExpression: function TaggedTemplateExpression(path, state) {
        // $FlowFixMe
        if (path[visited]) {
          return;
        }
        // $FlowFixMe
        path[visited] = true;
        if (
        // styled.h1`color:${color};`
        t.isMemberExpression(path.node.tag) && path.node.tag.object.name === state.importedNames.styled) {
          path.replaceWith(buildStyledCallExpression(path.node.tag.object, t.stringLiteral(path.node.tag.property.name), path, state, t));
        } else if (
        // styled('h1')`color:${color};`
        t.isCallExpression(path.node.tag) && path.node.tag.callee.name === state.importedNames.styled) {
          path.replaceWith(buildStyledCallExpression(path.node.tag.callee, path.node.tag.arguments[0], path, state, t));
        } else if (t.isIdentifier(path.node.tag)) {
          if (path.node.tag.name === state.importedNames.css || state.cssPropIdentifiers.indexOf(path.node.tag) !== -1) {
            replaceCssWithCallExpression(path, path.node.tag, state, t);
          } else if (path.node.tag.name === state.importedNames.keyframes) {
            replaceCssWithCallExpression(path, path.node.tag, state, t, function (src, name, hash) {
              return '@keyframes ' + name + '-' + hash + ' { ' + src + ' }';
            }, false, function () {
              return '';
            });
          } else if (path.node.tag.name === state.importedNames.injectGlobal) {
            replaceCssWithCallExpression(path, path.node.tag, state, t, undefined, true, function () {
              return '';
            });
          }
        }
      }
    }
  };
};

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _findRoot = require('find-root');

var _findRoot2 = _interopRequireDefault(_findRoot);

var _touch = require('touch');

var _helperModuleImports = require('@babel/helper-module-imports');

var _babelUtils = require('./babel-utils');

var _emotionUtils = require('emotion-utils');

var _sourceMap = require('./source-map');

var _cssProp = require('./css-prop');

var _cssProp2 = _interopRequireDefault(_cssProp);

var _astObject = require('./ast-object');

var _astObject2 = _interopRequireDefault(_astObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hashArray(arr) {
  return (0, _emotionUtils.hashString)(arr.join(''));
}

var staticStylis = new _emotionUtils.Stylis({ keyframe: false });

function hoistPureArgs(path) {
  var args = path.get('arguments');

  if (args && Array.isArray(args)) {
    args.forEach(function (arg) {
      if (!arg.isIdentifier() && arg.isPure()) {
        arg.hoist();
      }
    });
  }
}

function replaceCssWithCallExpression(path, identifier, state, t) {
  var staticCSSSrcCreator = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (src) {
    return src;
  };
  var removePath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var staticCSSSelectorCreator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function (name, hash) {
    return '.' + name + '-' + hash;
  };

  try {
    var _createRawStringFromT = (0, _babelUtils.createRawStringFromTemplateLiteral)(path.node.quasi),
        _hash = _createRawStringFromT.hash,
        _src = _createRawStringFromT.src;

    var identifierName = (0, _babelUtils.getIdentifierName)(path, t);
    var _name = (0, _babelUtils.getName)(identifierName, 'css');

    if (state.extractStatic && !path.node.quasi.expressions.length) {
      var staticCSSRules = staticStylis(staticCSSSelectorCreator(_name, _hash), staticCSSSrcCreator(_src, _name, _hash));
      state.insertStaticRules([staticCSSRules]);
      if (!removePath) {
        return path.replaceWith(t.stringLiteral(_name + '-' + _hash));
      }
      return path.replaceWith(t.identifier('undefined'));
    }

    if (!removePath) {
      path.addComment('leading', '#__PURE__');
    }
    if (state.opts.sourceMap === true && path.node.quasi.loc !== undefined) {
      _src += (0, _sourceMap.addSourceMaps)(path.node.quasi.loc.start, state);
    }

    var label = (0, _babelUtils.getLabel)(identifierName, state.opts.autoLabel, state.opts.labelFormat, state.file.opts.filename);

    path.replaceWith(t.callExpression(identifier, new _astObject2.default((0, _babelUtils.minify)(_src), path.node.quasi.expressions, t).toExpressions().concat(label ? [t.stringLiteral('label:' + label + ';')] : [])));

    if (state.opts.hoist) {
      hoistPureArgs(path);
    }

    return;
  } catch (e) {
    if (path) {
      throw path.buildCodeFrameError(e);
    }

    throw e;
  }
}

var unsafeRequire = require;

var getPackageRootPath = (0, _emotionUtils.memoize)(function (filename) {
  return (0, _findRoot2.default)(filename);
});

function buildTargetObjectProperty(path, state, t) {
  if (state.count === undefined) {
    state.count = 0;
  }

  var filename = state.file.opts.filename;

  // normalize the file path to ignore folder structure
  // outside the current node project and arch-specific delimiters
  var moduleName = '';
  var rootPath = filename;

  try {
    rootPath = getPackageRootPath(filename);
    moduleName = unsafeRequire(rootPath + '/package.json').name;
  } catch (err) {}

  var finalPath = filename === rootPath ? _path2.default.basename(filename) : filename.slice(rootPath.length);

  var positionInFile = state.count++;

  var stuffToHash = [moduleName];

  if (finalPath) {
    stuffToHash.push(_path2.default.normalize(finalPath));
  } else {
    stuffToHash.push(state.file.code);
  }

  var stableClassName = 'e' + hashArray(stuffToHash) + positionInFile;

  return t.objectProperty(t.identifier('target'), t.stringLiteral(stableClassName));
}
function buildStyledCallExpression(identifier, tag, path, state, t) {
  var identifierName = (0, _babelUtils.getIdentifierName)(path, t);

  var targetProperty = buildTargetObjectProperty(path, state, t);

  if (state.extractStatic && !path.node.quasi.expressions.length) {
    var _createRawStringFromT2 = (0, _babelUtils.createRawStringFromTemplateLiteral)(path.node.quasi),
        _hash2 = _createRawStringFromT2.hash,
        _src2 = _createRawStringFromT2.src;

    var staticClassName = 'css-' + _hash2;
    var staticCSSRules = staticStylis('.' + staticClassName, _src2);

    state.insertStaticRules([staticCSSRules]);

    return t.callExpression(t.callExpression(identifier, [tag, t.objectExpression([t.objectProperty(t.identifier('e'), t.stringLiteral(staticClassName)), targetProperty])]), []);
  }

  var _createRawStringFromT3 = (0, _babelUtils.createRawStringFromTemplateLiteral)(path.node.quasi),
      src = _createRawStringFromT3.src;

  path.addComment('leading', '#__PURE__');

  if (state.opts.sourceMap === true && path.node.quasi.loc !== undefined) {
    src += (0, _sourceMap.addSourceMaps)(path.node.quasi.loc.start, state);
  }

  var labelProperty = void 0;

  var label = (0, _babelUtils.getLabel)(identifierName, state.opts.autoLabel, state.opts.labelFormat, state.file.opts.filename);

  if (label) {
    labelProperty = t.objectProperty(t.identifier('label'), t.stringLiteral(label));
  }

  return t.callExpression(t.callExpression(identifier, [tag, t.objectExpression([labelProperty, targetProperty].filter(Boolean))]), new _astObject2.default((0, _babelUtils.minify)(src), path.node.quasi.expressions, t).toExpressions());
}

function buildStyledObjectCallExpression(path, state, identifier, t) {
  var targetProperty = buildTargetObjectProperty(path, state, t);
  var identifierName = (0, _babelUtils.getIdentifierName)(path, t);
  var tag = t.isCallExpression(path.node.callee) ? path.node.callee.arguments[0] : t.stringLiteral(path.node.callee.property.name);

  var args = path.node.arguments;
  if (state.opts.sourceMap === true && path.node.loc !== undefined) {
    args.push(t.stringLiteral((0, _sourceMap.addSourceMaps)(path.node.loc.start, state)));
  }

  var objectProperties = [targetProperty];
  var label = (0, _babelUtils.getLabel)(identifierName, state.opts.autoLabel, state.opts.labelFormat, state.file.opts.filename);

  if (label) {
    objectProperties.push(t.objectProperty(t.identifier('label'), t.stringLiteral(label)));
  }

  path.addComment('leading', '#__PURE__');

  return t.callExpression(t.callExpression(identifier, [tag, t.objectExpression(objectProperties)]), args);
}

var visited = Symbol('visited');

var defaultImportedNames = {
  styled: 'styled',
  css: 'css',
  keyframes: 'keyframes',
  injectGlobal: 'injectGlobal',
  merge: 'merge'
};

var importedNameKeys = Object.keys(defaultImportedNames).map(function (key) {
  return key === 'styled' ? 'default' : key;
});

var defaultEmotionPaths = ['emotion', 'react-emotion', 'preact-emotion'];

function getRelativePath(filepath, absoluteInstancePath) {
  var relativePath = _path2.default.relative(_path2.default.dirname(filepath), absoluteInstancePath);

  return relativePath.charAt(0) === '.' ? relativePath : './' + relativePath;
}

function getAbsolutePath(instancePath, rootPath) {
  if (instancePath.charAt(0) === '.') {
    var absoluteInstancePath = _path2.default.resolve(rootPath, instancePath);
    return absoluteInstancePath;
  }
  return false;
}

function getInstancePathToImport(instancePath, filepath) {
  var absolutePath = getAbsolutePath(instancePath, process.cwd());
  if (absolutePath === false) {
    return instancePath;
  }
  return getRelativePath(filepath, absolutePath);
}

function getInstancePathToCompare(instancePath, rootPath) {
  var absolutePath = getAbsolutePath(instancePath, rootPath);
  if (absolutePath === false) {
    return instancePath;
  }
  return absolutePath;
}